package server

import (
	"bytes"
	"fmt"
	"github.com/labstack/echo/v4"
	"io/ioutil"
	"net/http"
	"time"

	"github.com/google/uuid"
	"github.com/labstack/echo/v4/middleware"
	"github.com/labstack/gommon/log"
	"github.com/manta-coder/golang-serverless-example/pkg/httperror"
	"go.uber.org/zap"
)

// NewEcho creates an echo instance with defaults
func NewEcho(logger *zap.SugaredLogger, allowedOrigins ...string) *echo.Echo {
	e := echo.New()

	// remove logs generated by echo because it's not compatible with zap
	e.HideBanner = true
	e.HidePort = true
	e.Logger.SetLevel(log.OFF)

	// log requests/response
	e.Use(LoggerMiddleware(logger))
	// recover from panic inside a handler
	e.Use(RecoverMiddleware())
	e.Use(middleware.CORSWithConfig(middleware.CORSConfig{
		AllowOrigins: allowedOrigins,
		AllowMethods: []string{http.MethodGet, http.MethodPut, http.MethodPost, http.MethodDelete},
		AllowHeaders: []string{echo.HeaderOrigin, echo.HeaderContentType, echo.HeaderAccept, echo.HeaderAuthorization},
	}))

	e.HTTPErrorHandler = httperror.NewErrorHandler(logger)

	e.Pre(middleware.Rewrite(map[string]string{
		"/prod/*": "/$1",
		"/dev/*":  "/$1",
	}))

	return e
}

// RecoverMiddleware will catch any panics from the call stack. Must be registered after LoggerMiddleware to benefit from proper logging
func RecoverMiddleware() echo.MiddlewareFunc {
	return func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(c echo.Context) (err error) {
			defer func() {
				if r := recover(); r != nil {
					var ok bool

					err, ok = r.(error)
					if !ok {
						err = fmt.Errorf("%v", r)
					}

					// assign err so it returns to the next handler
					err = httperror.CorePanic(err)
				}
			}()

			err = next(c)
			return err
		}
	}
}

// LoggerMiddleware logs all request/responses
func LoggerMiddleware(logger *zap.SugaredLogger) echo.MiddlewareFunc {
	return func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(c echo.Context) error {
			id := uuid.New().String()
			req := c.Request()
			res := c.Response()
			start := time.Now()
			url := req.URL.String()

			// read the body payload into memory so we can log it later
			body, err := ioutil.ReadAll(req.Body)

			if err != nil {
				logger.Error("unable to read body into memory", zap.Error(err))
			}

			req.Body.Close()

			// create a new read closer from the in-memory payload so the next handler can read it
			req.Body = ioutil.NopCloser(bytes.NewReader(body))

			// create a response writer that copies the response body into memory to log later
			recorder := NewResponseWriterRecorder(res.Writer)
			res.Writer = recorder

			err = next(c)

			if err != nil {
				c.Error(err)
			}

			stop := time.Now()

			fields := []interface{}{
				zap.String("request_id", id),
				zap.ByteString("request_body", body),
				zap.String("response_body", recorder.Body()),
				zap.Int64("latency", stop.Sub(start).Milliseconds()),
				zap.String("url", url),
			}

			if err != nil {
				msg := fmt.Sprintf("%d %s %s - %s\n", res.Status, req.Method, c.Path(), err)
				logger.Warnw(msg, fields...)
			} else {
				msg := fmt.Sprintf("%d %s %s", res.Status, req.Method, c.Path())
				logger.Debugw(msg, fields...)
			}

			return nil
		}
	}
}
